use crate::datatypes::interface_version::InterfaceVersion;
use crate::datatypes::numeric_plan_indicator::NumericPlanIndicator;
use crate::datatypes::tlv::Tlv;
use crate::datatypes::{CommandId, CommandStatus, ToBytes, TypeOfNumber};
use bytes::{BufMut, Bytes, BytesMut};

#[derive(Clone, Debug, PartialEq)]
pub struct BindTransmitter {
    // pub command_length: u32,
    // pub command_id: CommandId::BindTransmitter,
    pub command_status: CommandStatus,
    pub sequence_number: u32,
    // body
    pub system_id: String,
    pub password: String,
    pub system_type: String,
    pub interface_version: InterfaceVersion,
    pub addr_ton: TypeOfNumber,
    pub addr_npi: NumericPlanIndicator,
    pub address_range: String,
}

#[derive(Clone, Debug, PartialEq)]
pub struct BindTransmitterResponse {
    // pub command_length: u32,
    // pub command_id: CommandId,
    pub command_status: CommandStatus,
    pub sequence_number: u32,
    // body
    pub system_id: String,
    pub sc_interface_version: Option<Tlv>,
}

impl ToBytes for BindTransmitter {
    fn to_bytes(&self) -> Bytes {
        let mut buffer = BytesMut::with_capacity(1024);

        // Write junk data that we'll replace later with the actual length
        buffer.put_u32(0_u32);

        buffer.put_u32(CommandId::BindTransmitter as u32);
        buffer.put_u32(self.command_status as u32);
        buffer.put_u32(self.sequence_number);

        buffer.put(self.system_id.as_bytes());
        buffer.put_u8(b'\0');

        buffer.put(self.password.as_bytes());
        buffer.put_u8(b'\0');

        buffer.put(self.system_type.as_bytes());
        buffer.put_u8(b'\0');

        buffer.put_u8(self.interface_version as u8);
        buffer.put_u8(self.addr_ton as u8);
        buffer.put_u8(self.addr_npi as u8);

        buffer.put(self.address_range.as_bytes());
        buffer.put_u8(b'\0');

        let length = buffer.len() as u32;

        let length_section = &mut buffer[0..][..4];
        length_section.copy_from_slice(&length.to_be_bytes());

        buffer.freeze()
    }
}

impl ToBytes for BindTransmitterResponse {
    fn to_bytes(&self) -> Bytes {
        let mut buffer = BytesMut::with_capacity(1024);

        // Write junk data that we'll replace later with the actual length
        buffer.put_u32(0_u32);

        buffer.put_u32(CommandId::BindTransmitter as u32);
        buffer.put_u32(self.command_status as u32);
        buffer.put_u32(self.sequence_number);

        if let Some(sc_interface_version) = &self.sc_interface_version {
            buffer.extend_from_slice(&sc_interface_version.to_bytes());
        } else {
            // todo: is this right?
            buffer.put_u8(b'\0');
        }

        let length = buffer.len() as u32;

        let length_section = &mut buffer[0..][..4];
        length_section.copy_from_slice(&length.to_be_bytes());

        buffer.freeze()
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn bind_transmitter_to_bytes() {
        let bind_transmitter = BindTransmitter {
            command_status: CommandStatus::Ok,
            sequence_number: 1,
            system_id: "SMPP3TEST".to_string(),
            password: "secret08".to_string(),
            system_type: "SUBMIT1".to_string(),
            interface_version: InterfaceVersion::SmppV34,
            addr_ton: TypeOfNumber::International,
            addr_npi: NumericPlanIndicator::Isdn,
            address_range: "".to_string(),
        };

        let bt_bytes = bind_transmitter.to_bytes();

        // Expected byte representation of a bind transmitter
        let expected: Vec<u8> = vec![
            // Header:
            0x00, 0x00, 0x00, 0x2F, // command_length
            0x00, 0x00, 0x00, 0x02, // command_id
            0x00, 0x00, 0x00, 0x00, // command_status
            0x00, 0x00, 0x00, 0x01, // sequence_number
            // Body:
            0x53, 0x4D, 0x50, 0x50, 0x33, 0x54, 0x45, 0x53, 0x54, 0x00, // system_id
            0x73, 0x65, 0x63, 0x72, 0x65, 0x74, 0x30, 0x38, 0x00, // password
            0x53, 0x55, 0x42, 0x4D, 0x49, 0x54, 0x31, 0x00, // system_type
            0x34, // interface_version
            0x01, // addr_ton
            0x01, // addr_npi
            0x00, // address_range
        ];

        assert_eq!(&bt_bytes, &expected);
    }
}
